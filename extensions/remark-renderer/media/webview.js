var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
// preview controller
(function () {
    var $ = null;
    var PreviewController = /** @class */ (function () {
        /**
         * This controller should be initialized when the html dom is loaded.
         */
        function PreviewController() {
            /**
             * VSCode API object got from acquireVsCodeApi
             */
            this.vscodeAPI = null;
            /**
             * Whether finished loading preview
             */
            this.doneLoadingPreview = false;
            /**
             * Whether to enable sidebar toc
             */
            this.enableSidebarTOC = false;
            /**
             * .sidebar-toc element
             */
            this.sidebarTOC = null;
            /**
             * .sidebar-toc element innerHTML generated by markdown-engine.ts
             */
            this.sidebarTOCHTML = "";
            this.refreshingIconTimeout = null;
            /**
             * Scroll map that maps buffer line to scrollTops of html elements
             */
            this.scrollMap = null;
            /**
             * TextEditor total buffer line count
             */
            this.totalLineCount = 0;
            /**
             * TextEditor cursor current line position
             */
            this.currentLine = -1;
            /**
             * TextEditor inital line position
             */
            this.initialLine = 0;
            /**
             * Used to delay preview scroll
             */
            this.previewScrollDelay = 0;
            /**
             * Track the slide line number, and (h, v) indices
             */
            this.slidesData = [];
            /**
             * Current slide offset
             */
            this.currentSlideOffset = -1;
            /**
             * SetTimeout value
             */
            this.scrollTimeout = null;
            /**
             * Configs
             */
            this.config = {};
            /**
             * Markdown file URI
             */
            this.sourceUri = null;
            /**
             * Caches
             */
            this.zenumlCache = {};
            this.wavedromCache = {};
            this.flowchartCache = {};
            this.sequenceDiagramCache = {};
            $ = window["$"];
            /** init preview elements */
            var previewElement = document.getElementsByClassName("mume")[0];
            var hiddenPreviewElement = document.createElement("div");
            hiddenPreviewElement.classList.add("mume");
            hiddenPreviewElement.classList.add("markdown-preview");
            hiddenPreviewElement.classList.add("hidden-preview");
            hiddenPreviewElement.setAttribute("for", "preview");
            hiddenPreviewElement.style.zIndex = "0";
            previewElement.insertAdjacentElement("beforebegin", hiddenPreviewElement);
            /** init `window` events */
            this.initWindowEvents();
            /** init contextmenu */
            this.initContextMenu();
            /** load config */
            this.config = JSON.parse(document.getElementById("mume-data").getAttribute("data-config"));
            this.sourceUri = this.config["sourceUri"];
            /*
          if (this.config.vscode) { // remove vscode default styles
            const defaultStyles = document.getElementById('_defaultStyles')
            if (defaultStyles) defaultStyles.remove()
          }
          */
            // console.log("init webview: " + this.sourceUri);
            // console.log(document.getElementsByTagName('html')[0].innerHTML)
            // console.log(JSON.stringify(config))
            /** init preview properties */
            (this.previewElement = previewElement),
                (this.hiddenPreviewElement = hiddenPreviewElement),
                (this.currentLine = this.config["line"] || -1);
            this.initialLine = this.config["initialLine"] || 0;
            this.presentationMode = previewElement.hasAttribute("data-presentation-mode");
            (this.toolbar = {
                toolbar: document.getElementById("md-toolbar"),
                backToTopBtn: document.getElementsByClassName("back-to-top-btn")[0],
                refreshBtn: document.getElementsByClassName("refresh-btn")[0],
                sidebarTOCBtn: document.getElementsByClassName("sidebar-toc-btn")[0]
            }),
                (this.refreshingIcon = document.getElementsByClassName("refreshing-icon")[0]),
                /** init toolbar event */
                this.initToolbarEvent();
            /** init image helper */
            this.initImageHelper();
            /** keyboard event */
            this.initKeyboardEvent();
            /** set zoom */
            this.setZoomLevel();
            /**
             * If it's not presentation mode, then we need to tell the parent window
             * that the preview is loaded, and the markdown needs to be updated so that
             * we can update properties like `sidebarTOCHTML`, etc...
             */
            if (!this.presentationMode) {
                previewElement.onscroll = this.scrollEvent.bind(this);
                this.postMessage("webviewFinishLoading", [this.sourceUri]);
            }
            else {
                // TODO: presentation preview to source sync
                this.config.scrollSync = true; // <= force to enable scrollSync for presentation
                this.initPresentationEvent();
            }
            // make it possible for interactive vega to load local data files
            var base = document.createElement("base");
            base.href = this.sourceUri;
            document.head.appendChild(base);
            // console.log(document.getElementsByTagName('html')[0].outerHTML)
        }
        /**
         * Post message to parent window
         * @param command
         * @param args
         */
        PreviewController.prototype.postMessage = function (command, args) {
            if (args === void 0) { args = []; }
            if (this.config.vscode) {
                if (!this.vscodeAPI) {
                    // @ts-ignore
                    this.vscodeAPI = acquireVsCodeApi();
                }
                // post message to vscode
                this.vscodeAPI.postMessage({
                    command: command,
                    args: args
                });
            }
            else {
                window.parent.postMessage({
                    command: command,
                    args: args
                }, "file://");
            }
        };
        /**
         * init events for tool bar
         */
        PreviewController.prototype.initToolbarEvent = function () {
            var toolbarElement = this.toolbar.toolbar;
            var showToolbar = function () { return (toolbarElement.style.opacity = "1"); };
            this.previewElement.onmouseenter = showToolbar;
            this.toolbar.toolbar.onmouseenter = showToolbar;
            this.previewElement.onmouseleave = function () {
                return (toolbarElement.style.opacity = "0");
            };
            this.initSideBarTOCButton();
            this.initBackToTopButton();
            this.initRefreshButton();
            return toolbar;
        };
        /**
         * init events for keyboard
         */
        PreviewController.prototype.initKeyboardEvent = function () {
            window.removeEventListener("keydown", this.keydown);
            window.addEventListener("keydown", this.keydown);
        };
        PreviewController.prototype.keydown = function (event) {
            this.postMessage("keydown", [this.sourceUri, event]);
        };
        /**
         * init .sidebar-toc-btn
         */
        PreviewController.prototype.initSideBarTOCButton = function () {
            var _this = this;
            this.toolbar.sidebarTOCBtn.onclick = function () {
                if (_this.presentationMode) {
                    return window["Reveal"].toggleOverview();
                }
                _this.enableSidebarTOC = !_this.enableSidebarTOC;
                if (_this.enableSidebarTOC) {
                    _this.sidebarTOC = document.createElement("div"); // create new sidebar toc
                    _this.sidebarTOC.classList.add("md-sidebar-toc");
                    document.body.appendChild(_this.sidebarTOC);
                    document.body.classList.add("show-sidebar-toc");
                    _this.renderSidebarTOC();
                    _this.bindTagAClickEvent();
                    _this.setZoomLevel();
                }
                else {
                    if (_this.sidebarTOC) {
                        _this.sidebarTOC.remove();
                    }
                    _this.sidebarTOC = null;
                    document.body.classList.remove("show-sidebar-toc");
                    _this.previewElement.style.width = "100%";
                }
                _this.scrollMap = null;
            };
        };
        /**
         * init .back-to-top-btn
         */
        PreviewController.prototype.initBackToTopButton = function () {
            var _this = this;
            this.toolbar.backToTopBtn.onclick = function () {
                if (_this.presentationMode) {
                    return window["Reveal"].slide(0);
                }
                _this.previewElement.scrollTop = 0;
            };
        };
        /**
         * init .refresh-btn
         */
        PreviewController.prototype.initRefreshButton = function () {
            var _this = this;
            this.toolbar.refreshBtn.onclick = function () {
                _this.postMessage("refreshPreview", [_this.sourceUri]);
            };
        };
        /**
         * init contextmenu
         * reference: http://jsfiddle.net/w33z4bo0/1/
         */
        PreviewController.prototype.initContextMenu = function () {
            var _this = this;
            $["contextMenu"]({
                selector: ".preview-container",
                items: {
                    open_in_browser: {
                        name: "Open in Browser",
                        callback: function () { return _this.postMessage("openInBrowser", [_this.sourceUri]); }
                    },
                    sep1: "---------",
                    html_export: {
                        name: "HTML",
                        items: {
                            html_offline: {
                                name: "HTML (offline)",
                                callback: function () {
                                    return _this.postMessage("htmlExport", [_this.sourceUri, true]);
                                }
                            },
                            html_cdn: {
                                name: "HTML (cdn hosted)",
                                callback: function () {
                                    return _this.postMessage("htmlExport", [_this.sourceUri, false]);
                                }
                            }
                        }
                    },
                    chrome_export: {
                        name: "Chrome (Puppeteer)",
                        items: {
                            chrome_pdf: {
                                name: "PDF",
                                callback: function () {
                                    return _this.postMessage("chromeExport", [_this.sourceUri, "pdf"]);
                                }
                            },
                            chrome_png: {
                                name: "PNG",
                                callback: function () {
                                    return _this.postMessage("chromeExport", [_this.sourceUri, "png"]);
                                }
                            },
                            chrome_jpeg: {
                                name: "JPEG",
                                callback: function () {
                                    return _this.postMessage("chromeExport", [_this.sourceUri, "jpeg"]);
                                }
                            }
                        }
                    },
                    prince_export: {
                        name: "PDF (prince)",
                        callback: function () { return _this.postMessage("princeExport", [_this.sourceUri]); }
                    },
                    ebook_export: {
                        name: "eBook",
                        items: {
                            ebook_epub: {
                                name: "ePub",
                                callback: function () {
                                    return _this.postMessage("eBookExport", [_this.sourceUri, "epub"]);
                                }
                            },
                            ebook_mobi: {
                                name: "mobi",
                                callback: function () {
                                    return _this.postMessage("eBookExport", [_this.sourceUri, "mobi"]);
                                }
                            },
                            ebook_pdf: {
                                name: "PDF",
                                callback: function () {
                                    return _this.postMessage("eBookExport", [_this.sourceUri, "pdf"]);
                                }
                            },
                            ebook_html: {
                                name: "HTML",
                                callback: function () {
                                    return _this.postMessage("eBookExport", [_this.sourceUri, "html"]);
                                }
                            }
                        }
                    },
                    pandoc_export: {
                        name: "Pandoc",
                        callback: function () { return _this.postMessage("pandocExport", [_this.sourceUri]); }
                    },
                    save_as_markdown: {
                        name: "Save as Markdown",
                        callback: function () {
                            return _this.postMessage("markdownExport", [_this.sourceUri]);
                        }
                    },
                    sep2: "---------",
                    image_helper: {
                        name: "Image Helper",
                        callback: function () { return window["$"]("#image-helper-view").modal(); }
                    },
                    sep3: "---------",
                    sync_source: {
                        name: "Sync Source",
                        callback: function () { return _this.previewSyncSource(); }
                    },
                    seq4: "---------",
                    preview_theme: {
                        name: "Preview Theme",
                        items: {
                            atom_dark_css: {
                                name: "atom-dark.css",
                                callback: function () {
                                    _this.postMessage("setPreviewTheme", [
                                        _this.sourceUri,
                                        "atom-dark.css",
                                    ]);
                                }
                            },
                            atom_light_css: {
                                name: "atom-light.css",
                                callback: function () {
                                    _this.postMessage("setPreviewTheme", [
                                        _this.sourceUri,
                                        "atom-light.css",
                                    ]);
                                }
                            },
                            atom_material_css: {
                                name: "atom-material.css",
                                callback: function () {
                                    _this.postMessage("setPreviewTheme", [
                                        _this.sourceUri,
                                        "atom-material.css",
                                    ]);
                                }
                            },
                            github_dark_css: {
                                name: "github-dark.css",
                                callback: function () {
                                    _this.postMessage("setPreviewTheme", [
                                        _this.sourceUri,
                                        "github-dark.css",
                                    ]);
                                }
                            },
                            github_light_css: {
                                name: "github-light.css",
                                callback: function () {
                                    _this.postMessage("setPreviewTheme", [
                                        _this.sourceUri,
                                        "github-light.css",
                                    ]);
                                }
                            },
                            gothic_css: {
                                name: "gothic.css",
                                callback: function () {
                                    _this.postMessage("setPreviewTheme", [
                                        _this.sourceUri,
                                        "gothic.css",
                                    ]);
                                }
                            },
                            medium_css: {
                                name: "medium.css",
                                callback: function () {
                                    _this.postMessage("setPreviewTheme", [
                                        _this.sourceUri,
                                        "medium.css",
                                    ]);
                                }
                            },
                            monokai_css: {
                                name: "monokai.css",
                                callback: function () {
                                    _this.postMessage("setPreviewTheme", [
                                        _this.sourceUri,
                                        "monokai.css",
                                    ]);
                                }
                            },
                            newsprint_css: {
                                name: "newsprint.css",
                                callback: function () {
                                    _this.postMessage("setPreviewTheme", [
                                        _this.sourceUri,
                                        "newsprint.css",
                                    ]);
                                }
                            },
                            night_css: {
                                name: "night.css",
                                callback: function () {
                                    _this.postMessage("setPreviewTheme", [
                                        _this.sourceUri,
                                        "night.css",
                                    ]);
                                }
                            },
                            none_css: {
                                name: "none.css",
                                callback: function () {
                                    _this.postMessage("setPreviewTheme", [
                                        _this.sourceUri,
                                        "none.css",
                                    ]);
                                }
                            },
                            one_dark_css: {
                                name: "one-dark.css",
                                callback: function () {
                                    _this.postMessage("setPreviewTheme", [
                                        _this.sourceUri,
                                        "one-dark.css",
                                    ]);
                                }
                            },
                            one_light_css: {
                                name: "one-light.css",
                                callback: function () {
                                    _this.postMessage("setPreviewTheme", [
                                        _this.sourceUri,
                                        "one-light.css",
                                    ]);
                                }
                            },
                            solarized_dark_css: {
                                name: "solarized-dark.css",
                                callback: function () {
                                    _this.postMessage("setPreviewTheme", [
                                        _this.sourceUri,
                                        "solarized-dark.css",
                                    ]);
                                }
                            },
                            solarized_light_css: {
                                name: "solarized-light.css",
                                callback: function () {
                                    _this.postMessage("setPreviewTheme", [
                                        _this.sourceUri,
                                        "solarized-light.css",
                                    ]);
                                }
                            },
                            vue_css: {
                                name: "vue.css",
                                callback: function () {
                                    _this.postMessage("setPreviewTheme", [
                                        _this.sourceUri,
                                        "vue.css",
                                    ]);
                                }
                            }
                        }
                    }
                }
            });
        };
        /**
         * init image helper
         */
        PreviewController.prototype.initImageHelper = function () {
            var _this = this;
            var imageHelper = document.getElementById("image-helper-view");
            // url editor
            // used to insert image url
            var urlEditor = imageHelper.getElementsByClassName("url-editor")[0];
            urlEditor.addEventListener("keypress", function (event) {
                if (event.keyCode === 13) {
                    // enter key pressed
                    var url = urlEditor.value.trim();
                    if (url.indexOf(" ") >= 0) {
                        url = "<".concat(url, ">");
                    }
                    if (url.length) {
                        $["modal"].close(); // close modal
                        _this.postMessage("insertImageUrl", [_this.sourceUri, url]);
                    }
                    return false;
                }
                else {
                    return true;
                }
            });
            var copyLabel = imageHelper.getElementsByClassName("copy-label")[0];
            copyLabel.innerText = "Copy image to ".concat(this.config.imageFolderPath[0] === "/" ? "workspace" : "relative", " ").concat(this.config.imageFolderPath, " folder");
            var imageUploaderSelect = imageHelper.getElementsByClassName("uploader-select")[0];
            imageUploaderSelect.value = this.config.imageUploader;
            // drop area has 2 events:
            // 1. paste(copy) image to imageFolderPath
            // 2. upload image
            var dropArea = window["$"](".drop-area", imageHelper);
            var fileUploader = window["$"](".file-uploader", imageHelper);
            dropArea.on("drop dragend dragstart dragenter dragleave drag dragover", function (e) {
                e.preventDefault();
                e.stopPropagation();
                if (e.type === "drop") {
                    if (e.target.className.indexOf("paster") >= 0) {
                        // paste
                        var files = e.originalEvent.dataTransfer.files;
                        for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
                            var file = files_1[_i];
                            _this.postMessage("pasteImageFile", [_this.sourceUri, file.path]);
                        }
                    }
                    else {
                        // upload
                        var files = e.originalEvent.dataTransfer.files;
                        for (var _a = 0, files_2 = files; _a < files_2.length; _a++) {
                            var file = files_2[_a];
                            _this.postMessage("uploadImageFile", [
                                _this.sourceUri,
                                file.path,
                                imageUploaderSelect.value,
                            ]);
                        }
                    }
                    $["modal"].close(); // close modal
                }
            });
            dropArea.on("click", function (e) {
                e.preventDefault();
                e.stopPropagation();
                window["$"](this)
                    .find('input[type="file"]')
                    .click();
                $["modal"].close(); // close modal
            });
            fileUploader.on("click", function (e) {
                e.stopPropagation();
            });
            fileUploader.on("change", function (e) {
                if (e.target.className.indexOf("paster") >= 0) {
                    // paste
                    var files = e.target.files;
                    for (var _i = 0, files_3 = files; _i < files_3.length; _i++) {
                        var file = files_3[_i];
                        _this.postMessage("pasteImageFile", [_this.sourceUri, file.path]);
                    }
                    fileUploader.val("");
                }
                else {
                    // upload
                    var files = e.target.files;
                    for (var _a = 0, files_4 = files; _a < files_4.length; _a++) {
                        var file = files_4[_a];
                        _this.postMessage("uploadImageFile", [
                            _this.sourceUri,
                            file.path,
                            imageUploaderSelect.value,
                        ]);
                    }
                    fileUploader.val("");
                }
            });
            // show image uploaded history
            var a = imageHelper.querySelector("#show-uploaded-image-history");
            a.onclick = function (event) {
                event.preventDefault();
                event.stopPropagation();
                $["modal"].close();
                _this.postMessage("showUploadedImageHistory", [_this.sourceUri]);
            };
        };
        /**
         * Init several events for presentation mode
         */
        PreviewController.prototype.initPresentationEvent = function () {
            var _this = this;
            var initialSlide = null;
            var readyEvent = function () {
                if (initialSlide) {
                    initialSlide.style.visibility = "visible";
                }
                // several events...
                _this.setupCodeChunks();
                _this.bindTagAClickEvent();
                _this.bindTaskListEvent();
                // scroll slides
                window["Reveal"].addEventListener("slidechanged", function (event) {
                    if (Date.now() < _this.previewScrollDelay) {
                        return;
                    }
                    var indexh = event.indexh, indexv = event.indexv;
                    for (var _i = 0, _a = _this.slidesData; _i < _a.length; _i++) {
                        var slideData = _a[_i];
                        var h = slideData.h, v = slideData.v, line = slideData.line;
                        if (h === indexh && v === indexv) {
                            _this.postMessage("revealLine", [_this.sourceUri, line + 6]);
                        }
                    }
                });
            };
            // analyze slides
            this.initSlidesData();
            // slide to initial position
            window["Reveal"].configure({ transition: "none" });
            this.scrollToRevealSourceLine(this.initialLine);
            window["Reveal"].configure({ transition: "slide" });
            initialSlide = window["Reveal"].getCurrentSlide();
            if (initialSlide) {
                initialSlide.style.visibility = "hidden";
            }
            if (window["Reveal"].isReady()) {
                readyEvent();
            }
            else {
                window["Reveal"].addEventListener("ready", readyEvent);
            }
        };
        // zoom in preview
        PreviewController.prototype.zoomIn = function () {
            this.config.zoomLevel = (this.config.zoomLevel || 1) + 0.1;
            this.setZoomLevel();
        };
        // zoom out preview
        PreviewController.prototype.zoomOut = function () {
            this.config.zoomLevel = (this.config.zoomLevel || 1) - 0.1;
            this.setZoomLevel();
        };
        // reset preview zoom
        PreviewController.prototype.resetZoom = function () {
            this.config.zoomLevel = 1;
            this.setZoomLevel();
        };
        PreviewController.prototype.setZoomLevel = function () {
            var zoomLevel = this.config.zoomLevel || 1;
            this.previewElement.style["zoom"] = zoomLevel.toString();
            if (this.enableSidebarTOC) {
                this.previewElement.style.width = "calc(100% - ".concat(268 / zoomLevel, "px)");
            }
            this.scrollMap = null;
            if (!this.config.vscode) {
                this.postMessage("setZoomLevel", [this.sourceUri, zoomLevel]);
            }
        };
        /**
         * render mermaid graphs
         */
        PreviewController.prototype.renderMermaid = function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var mermaid = window["mermaid"]; // window.mermaid doesn't work, has to be written as window['mermaid']
                var mermaidGraphs = _this.previewElement.getElementsByClassName("mermaid");
                var validMermaidGraphs = [];
                for (var i = 0; i < mermaidGraphs.length; i++) {
                    var mermaidGraph = mermaidGraphs[i];
                    try {
                        mermaid.parse(mermaidGraph.textContent.trim());
                        validMermaidGraphs.push(mermaidGraph);
                    }
                    catch (error) {
                        mermaidGraph.innerHTML = "<pre class=\"language-text\">".concat(error.str.toString(), "</pre>");
                    }
                }
                if (!validMermaidGraphs.length) {
                    return resolve();
                }
                else {
                    validMermaidGraphs.forEach(function (mermaidGraph, offset) {
                        var svgId = "svg-mermaid-" + Date.now() + "-" + offset;
                        var code = mermaidGraph.textContent.trim();
                        try {
                            mermaid.render(svgId, code, function (svgCode) {
                                mermaidGraph.innerHTML = svgCode;
                            });
                        }
                        catch (error) {
                            var noiseElement = document.getElementById("d" + svgId);
                            if (noiseElement) {
                                noiseElement.style.display = "none";
                            }
                            mermaidGraph.innerHTML = "<pre class=\"language-text\">".concat(error.toString(), "</pre>");
                        }
                    });
                    return resolve();
                }
            });
        };
        /**
         * render interactive vega and vega lite
         * This function is copied from render flowchart
         */
        PreviewController.prototype.renderInteractiveVega = function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var vegaElements = _this.previewElement.querySelectorAll(".vega, .vega-lite");
                function reportVegaError(el, error) {
                    el.innerHTML =
                        '<pre class="language-text">' + error.toString() + "</pre>";
                }
                var _loop_1 = function (i) {
                    var vegaElement = vegaElements[i];
                    try {
                        var spec = JSON.parse(vegaElement.textContent.trim());
                        window["vegaEmbed"](vegaElement, spec, { actions: false })["catch"](function (error) {
                            reportVegaError(vegaElement, error);
                        });
                    }
                    catch (error) {
                        reportVegaError(vegaElement, error);
                    }
                };
                for (var i = 0; i < vegaElements.length; i++) {
                    _loop_1(i);
                }
                resolve();
            });
        };
        /**
         * render flowchart
         * This function doesn't work with `hiddenPreviewElement`
         */
        PreviewController.prototype.renderFlowchart = function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var flowcharts = _this.previewElement.getElementsByClassName("flow");
                var newFlowchartCache = {};
                for (var i = 0; i < flowcharts.length; i++) {
                    var flow = flowcharts[i];
                    var text = flow.textContent.trim();
                    if (text in _this.flowchartCache) {
                        flow.innerHTML = _this.flowchartCache[text];
                    }
                    else {
                        try {
                            var diagram = window["flowchart"].parse(text);
                            flow.innerHTML = "";
                            diagram.drawSVG(flow);
                        }
                        catch (error) {
                            flow.innerHTML =
                                '<pre class="language-text">' + error.toString() + "</pre>";
                        }
                    }
                    newFlowchartCache[text] = flow.innerHTML;
                }
                _this.flowchartCache = newFlowchartCache;
                resolve();
            });
        };
        /**
         * render sequence diagram
         */
        PreviewController.prototype.renderSequenceDiagram = function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var sequenceDiagrams = _this.previewElement.getElementsByClassName("sequence");
                var newSequenceDiagramCache = {};
                for (var i = 0; i < sequenceDiagrams.length; i++) {
                    var sequence = sequenceDiagrams[i];
                    var text = sequence.textContent.trim();
                    var theme = sequence.getAttribute("theme") || "simple";
                    var cacheKey = text + "$" + theme;
                    if (cacheKey in _this.sequenceDiagramCache) {
                        sequence.innerHTML = _this.sequenceDiagramCache[cacheKey];
                    }
                    else {
                        try {
                            var diagram = window["Diagram"].parse(text);
                            sequence.innerHTML = "";
                            diagram.drawSVG(sequence, { theme: theme });
                        }
                        catch (error) {
                            sequence.innerHTML =
                                '<pre class="language-text">' + error.toString() + "</pre>";
                        }
                    }
                    newSequenceDiagramCache[cacheKey] = sequence.innerHTML;
                }
                _this.sequenceDiagramCache = newSequenceDiagramCache;
                resolve();
            });
        };
        /**
         * render wavedrom
         */
        PreviewController.prototype.renderWavedrom = function () {
            return __awaiter(this, void 0, void 0, function () {
                var els, wavedromCache, i, el, text, svg, content;
                return __generator(this, function (_a) {
                    els = this.hiddenPreviewElement.getElementsByClassName("wavedrom");
                    if (els.length) {
                        wavedromCache = {};
                        for (i = 0; i < els.length; i++) {
                            el = els[i];
                            el.id = "wavedrom" + i;
                            text = el.textContent.trim();
                            if (!text.length) {
                                continue;
                            }
                            if (text in this.wavedromCache) {
                                svg = this.wavedromCache[text];
                                el.innerHTML = svg;
                                wavedromCache[text] = svg;
                                continue;
                            }
                            try {
                                content = eval("(".concat(text, ")"));
                                window["WaveDrom"].RenderWaveForm(i, content, "wavedrom");
                                wavedromCache[text] = el.innerHTML;
                            }
                            catch (error) {
                                el.innerText = "Failed to eval WaveDrom code. " + error;
                            }
                        }
                        this.wavedromCache = wavedromCache;
                    }
                    return [2 /*return*/];
                });
            });
        };
        /**UML
         * render zenuml
         */
        PreviewController.prototype.renderZenUML = function () {
            return __awaiter(this, void 0, void 0, function () {
                var els, zenumlCache, i, el, text, svg, content;
                return __generator(this, function (_a) {
                    els = this.hiddenPreviewElement.getElementsByClassName("zenuml");
                    if (els.length) {
                        zenumlCache = {};
                        for (i = 0; i < els.length; i++) {
                            el = els[i];
                            el.id = "zenuml" + i;
                            text = el.textContent.trim();
                            if (!text.length) {
                                continue;
                            }
                            if (text in this.zenumlCache) {
                                svg = this.zenumlCache[text];
                                el.innerHTML = svg;
                                zenumlCache[text] = svg;
                                continue;
                            }
                            try {
                                content = "<sequence-diagram>".concat(text, "</sequence-diagram>");
                                // window["WaveDrom"].RenderWaveForm(i, content, "wavedrom");
                                el.innerHTML = content;
                                zenumlCache[text] = el.innerHTML;
                            }
                            catch (error) {
                                el.innerText = "Failed to eval ZenUML code. " + error;
                            }
                        }
                        this.zenumlCache = zenumlCache;
                    }
                    return [2 /*return*/];
                });
            });
        };
        /**
         * render MathJax expressions
         */
        PreviewController.prototype.renderMathJax = function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                if (_this.config.mathRenderingOption === "MathJax" ||
                    _this.config.usePandocParser) {
                    var MathJax = window["MathJax"];
                    // .mathjax-exps, .math.inline, .math.display
                    var unprocessedElements = _this.hiddenPreviewElement.querySelectorAll(".mathjax-exps, .math.inline, .math.display");
                    if (!unprocessedElements.length) {
                        return resolve();
                    }
                    window["MathJax"].Hub.Queue(["Typeset", MathJax.Hub, _this.hiddenPreviewElement], [
                        function () {
                            // sometimes the this callback will be called twice
                            // and only the second time will the Math expressions be rendered.
                            // therefore, I added the line below to check whether math is already rendered.
                            if (!_this.hiddenPreviewElement.getElementsByClassName("MathJax")
                                .length) {
                                return;
                            }
                            _this.scrollMap = null;
                            return resolve();
                        },
                    ]);
                }
                else {
                    return resolve();
                }
            });
        };
        /**
         * Run code chunk with 'id'
         * @param id
         */
        PreviewController.prototype.runCodeChunk = function (id) {
            if (!this.config.enableScriptExecution) {
                return;
            }
            var codeChunk = document.querySelector(".code-chunk[data-id=\"".concat(id, "\"]"));
            var running = codeChunk.classList.contains("running");
            if (running) {
                return;
            }
            codeChunk.classList.add("running");
            if (codeChunk.getAttribute("data-cmd") === "javascript") {
                // javascript code chunk
                var code = codeChunk.getAttribute("data-code");
                try {
                    eval("((function(){".concat(code, "$})())"));
                    codeChunk.classList.remove("running"); // done running javascript code
                    var CryptoJS = window["CryptoJS"];
                    var result = CryptoJS.AES.encrypt(codeChunk.getElementsByClassName("output-div")[0].outerHTML, "mume").toString();
                    this.postMessage("cacheCodeChunkResult", [
                        this.sourceUri,
                        id,
                        result,
                    ]);
                }
                catch (e) {
                    var outputDiv = codeChunk.getElementsByClassName("output-div")[0];
                    outputDiv.innerHTML = "<pre>".concat(e.toString(), "</pre>");
                }
            }
            else {
                this.postMessage("runCodeChunk", [this.sourceUri, id]);
            }
        };
        /**
         * Run all code chunks
         */
        PreviewController.prototype.runAllCodeChunks = function () {
            if (!this.config.enableScriptExecution) {
                return;
            }
            var codeChunks = this.previewElement.getElementsByClassName("code-chunk");
            for (var i = 0; i < codeChunks.length; i++) {
                codeChunks[i].classList.add("running");
            }
            this.postMessage("runAllCodeChunks", [this.sourceUri]);
        };
        /**
         * Run the code chunk that is the nearest to this.currentLine
         */
        PreviewController.prototype.runNearestCodeChunk = function () {
            var currentLine = this.currentLine;
            var elements = this.previewElement.children;
            for (var i = elements.length - 1; i >= 0; i--) {
                if (elements[i].classList.contains("sync-line") &&
                    elements[i + 1] &&
                    elements[i + 1].classList.contains("code-chunk")) {
                    if (currentLine >= parseInt(elements[i].getAttribute("data-line"), 10)) {
                        var codeChunkId = elements[i + 1].getAttribute("data-id");
                        return this.runCodeChunk(codeChunkId);
                    }
                }
            }
        };
        /**
         * Setup code chunks
         */
        PreviewController.prototype.setupCodeChunks = function () {
            var _this = this;
            var codeChunks = this.previewElement.getElementsByClassName("code-chunk");
            if (!codeChunks.length) {
                return;
            }
            var _loop_2 = function (i) {
                var codeChunk = codeChunks[i];
                var id = codeChunk.getAttribute("data-id");
                // bind click event
                var runBtn = codeChunk.getElementsByClassName("run-btn")[0];
                var runAllBtn = codeChunk.getElementsByClassName("run-all-btn")[0];
                if (runBtn) {
                    runBtn.addEventListener("click", function () {
                        _this.runCodeChunk(id);
                    });
                }
                if (runAllBtn) {
                    runAllBtn.addEventListener("click", function () {
                        _this.runAllCodeChunks();
                    });
                }
            };
            for (var i = 0; i < codeChunks.length; i++) {
                _loop_2(i);
            }
        };
        /**
         * render sidebar toc
         */
        PreviewController.prototype.renderSidebarTOC = function () {
            if (!this.enableSidebarTOC) {
                return;
            }
            if (this.sidebarTOCHTML) {
                this.sidebarTOC.innerHTML = this.sidebarTOCHTML;
            }
            else {
                this.sidebarTOC.innerHTML = "<p style=\"text-align:center;font-style: italic;\">Outline (empty)</p>";
            }
        };
        /**
         * init several preview events
         */
        PreviewController.prototype.initEvents = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, Promise.all([
                                this.renderMathJax(),
                                this.renderZenUML(),
                                this.renderWavedrom(),
                            ])];
                        case 1:
                            _a.sent();
                            this.previewElement.innerHTML = this.hiddenPreviewElement.innerHTML;
                            this.hiddenPreviewElement.innerHTML = "";
                            return [4 /*yield*/, Promise.all([
                                    this.renderFlowchart(),
                                    this.renderInteractiveVega(),
                                    this.renderSequenceDiagram(),
                                    this.renderMermaid(),
                                ])];
                        case 2:
                            _a.sent();
                            this.setupCodeChunks();
                            if (this.refreshingIconTimeout) {
                                clearTimeout(this.refreshingIconTimeout);
                                this.refreshingIconTimeout = null;
                            }
                            this.refreshingIcon.style.display = "none";
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Bind <a href="..."></a> click events.
         */
        PreviewController.prototype.bindTagAClickEvent = function () {
            var _this = this;
            var helper = function (as) {
                var _loop_3 = function (i) {
                    var a = as[i];
                    var href = decodeURIComponent(a.getAttribute("href")); // decodeURI here for Chinese like unicode heading
                    if (href && href[0] === "#") {
                        var targetElement_1 = _this.previewElement.querySelector("[id=\"".concat(encodeURIComponent(href.slice(1)), "\"]")); // fix number id bug
                        if (targetElement_1) {
                            a.onclick = function (event) {
                                event.preventDefault();
                                event.stopPropagation();
                                // jump to tag position
                                var offsetTop = 0;
                                var el = targetElement_1;
                                while (el && el !== _this.previewElement) {
                                    offsetTop += el.offsetTop;
                                    el = el.offsetParent;
                                }
                                if (_this.previewElement.scrollTop > offsetTop) {
                                    _this.previewElement.scrollTop =
                                        offsetTop - 32 - targetElement_1.offsetHeight;
                                }
                                else {
                                    _this.previewElement.scrollTop = offsetTop;
                                }
                            };
                        }
                        else {
                            // without the `else` here, mpe package on Atom will fail to render preview (issue #824 and #827).
                            a.onclick = function (event) {
                                event.preventDefault();
                                event.stopPropagation();
                            };
                        }
                    }
                    else {
                        a.onclick = function (event) {
                            event.preventDefault();
                            event.stopPropagation();
                            _this.postMessage("clickTagA", [
                                _this.sourceUri,
                                encodeURIComponent(href.replace(/\\/g, "/")),
                            ]);
                        };
                    }
                };
                for (var i = 0; i < as.length; i++) {
                    _loop_3(i);
                }
            };
            helper(this.previewElement.getElementsByTagName("a"));
            if (this.sidebarTOC) {
                helper(this.sidebarTOC.getElementsByTagName("a"));
            }
        };
        /**
         * Initialize Tast list items checkbox click event.
         */
        PreviewController.prototype.bindTaskListEvent = function () {
            var _this = this;
            var taskListItemCheckboxes = this.previewElement.getElementsByClassName("task-list-item-checkbox");
            var _loop_4 = function (i) {
                var checkbox = taskListItemCheckboxes[i];
                var li = checkbox.parentElement;
                if (li.tagName !== "LI") {
                    li = li.parentElement;
                }
                if (li.tagName === "LI") {
                    li.classList.add("task-list-item");
                    // bind checkbox click event
                    checkbox.onclick = function (event) {
                        event.preventDefault();
                        var checked = checkbox.checked;
                        if (checked) {
                            checkbox.setAttribute("checked", "");
                        }
                        else {
                            checkbox.removeAttribute("checked");
                        }
                        var dataLine = parseInt(checkbox.getAttribute("data-line"), 10);
                        if (!isNaN(dataLine)) {
                            _this.postMessage("clickTaskListCheckbox", [
                                _this.sourceUri,
                                dataLine,
                            ]);
                        }
                    };
                }
            };
            for (var i = 0; i < taskListItemCheckboxes.length; i++) {
                _loop_4(i);
            }
        };
        /**
         * update previewElement innerHTML content
         * @param html
         */
        PreviewController.prototype.updateHTML = function (html, id, classes) {
            var _this = this;
            // If it's now presentationMode, then this function shouldn't be called.
            // If this function is called, then it might be in the case that
            //   1. Using singlePreview
            //   2. Switch from a presentationMode file to not presentationMode file.
            if (this.presentationMode) {
                this.postMessage("refreshPreview", [this.sourceUri]);
            }
            // editorScrollDelay = Date.now() + 500
            this.previewScrollDelay = Date.now() + 500;
            this.hiddenPreviewElement.innerHTML = html;
            var scrollTop = this.previewElement.scrollTop;
            // init several events
            this.initEvents().then(function () {
                _this.scrollMap = null;
                _this.bindTagAClickEvent();
                _this.bindTaskListEvent();
                // set id and classes
                _this.previewElement.id = id || "";
                _this.previewElement.setAttribute("class", "mume markdown-preview ".concat(classes));
                // scroll to initial position
                if (!_this.doneLoadingPreview) {
                    _this.doneLoadingPreview = true;
                    _this.scrollToRevealSourceLine(_this.initialLine);
                    // clear @scrollMap after 2 seconds because sometimes
                    // loading images will change scrollHeight.
                    setTimeout(function () { return (_this.scrollMap = null); }, 2000);
                }
                else {
                    // restore scrollTop
                    _this.previewElement.scrollTop = scrollTop; // <= This line is necessary...
                }
            });
        };
        /**
         * Build offsets for each line (lines can be wrapped)
         * That's a bit dirty to process each line everytime, but ok for demo.
         * Optimizations are required only for big texts.
         * @return number[]
         */
        PreviewController.prototype.buildScrollMap = function () {
            if (!this.totalLineCount) {
                return null;
            }
            var scrollMap = [];
            var nonEmptyList = [];
            for (var i = 0; i < this.totalLineCount; i++) {
                scrollMap.push(-1);
            }
            nonEmptyList.push(0);
            scrollMap[0] = 0;
            // write down the offsetTop of element that has 'data-line' property to scrollMap
            var lineElements = this.previewElement.getElementsByClassName("sync-line");
            for (var i = 0; i < lineElements.length; i++) {
                var el = lineElements[i];
                var t = el.getAttribute("data-line");
                if (!t) {
                    continue;
                }
                t = parseInt(t, 10);
                if (!t) {
                    continue;
                }
                // this is for ignoring footnote scroll match
                if (t < nonEmptyList[nonEmptyList.length - 1]) {
                    el.removeAttribute("data-line");
                }
                else {
                    nonEmptyList.push(t);
                    var offsetTop = 0;
                    while (el && el !== this.previewElement) {
                        offsetTop += el.offsetTop;
                        el = el.offsetParent;
                    }
                    scrollMap[t] = Math.round(offsetTop);
                }
            }
            nonEmptyList.push(this.totalLineCount);
            scrollMap.push(this.previewElement.scrollHeight);
            var pos = 0;
            for (var i = 0; i < this.totalLineCount; i++) {
                if (scrollMap[i] !== -1) {
                    pos++;
                    continue;
                }
                var a = nonEmptyList[pos - 1];
                var b = nonEmptyList[pos];
                scrollMap[i] = Math.round((scrollMap[b] * (i - a) + scrollMap[a] * (b - i)) / (b - a));
            }
            return scrollMap; // scrollMap's length == screenLineCount (vscode can't get screenLineCount... sad)
        };
        PreviewController.prototype.scrollEvent = function () {
            if (!this.config.scrollSync) {
                return;
            }
            if (!this.scrollMap) {
                this.scrollMap = this.buildScrollMap();
                return;
            }
            if (Date.now() < this.previewScrollDelay) {
                return;
            }
            this.previewSyncSource();
        };
        PreviewController.prototype.previewSyncSource = function () {
            var scrollToLine;
            if (this.previewElement.scrollTop === 0) {
                // editorScrollDelay = Date.now() + 100
                scrollToLine = 0;
                this.postMessage("revealLine", [this.sourceUri, scrollToLine]);
                return;
            }
            var top = this.previewElement.scrollTop + this.previewElement.offsetHeight / 2;
            // try to find corresponding screen buffer row
            if (!this.scrollMap) {
                this.scrollMap = this.buildScrollMap();
            }
            var i = 0;
            var j = this.scrollMap.length - 1;
            var count = 0;
            var screenRow = -1; // the screenRow is the bufferRow in vscode.
            var mid;
            while (count < 20) {
                if (Math.abs(top - this.scrollMap[i]) < 20) {
                    screenRow = i;
                    break;
                }
                else if (Math.abs(top - this.scrollMap[j]) < 20) {
                    screenRow = j;
                    break;
                }
                else {
                    mid = Math.floor((i + j) / 2);
                    if (top > this.scrollMap[mid]) {
                        i = mid;
                    }
                    else {
                        j = mid;
                    }
                }
                count++;
            }
            if (screenRow === -1) {
                screenRow = mid;
            }
            scrollToLine = screenRow;
            this.postMessage("revealLine", [this.sourceUri, scrollToLine]);
            // @scrollToPos(screenRow * @editor.getLineHeightInPixels() - @previewElement.offsetHeight / 2, @editor.getElement())
            // # @editor.getElement().setScrollTop
            // track currnet time to disable onDidChangeScrollTop
            // editorScrollDelay = Date.now() + 100
        };
        /**
         * Analyze slides and generate `this.slidesData`
         */
        PreviewController.prototype.initSlidesData = function () {
            var slideElements = document.getElementsByTagName("section");
            var offset = 0;
            for (var i = 0; i < slideElements.length; i++) {
                var slide = slideElements[i];
                if (slide.hasAttribute("data-line")) {
                    var line = parseInt(slide.getAttribute("data-line"), 10);
                    var h = parseInt(slide.getAttribute("data-h"), 10);
                    var v = parseInt(slide.getAttribute("data-v"), 10);
                    this.slidesData.push({ line: line, h: h, v: v, offset: offset });
                    offset += 1;
                }
            }
        };
        /**
         * scroll sync to display slide according `line`
         * @param: line: the buffer row of editor
         */
        PreviewController.prototype.scrollSyncToSlide = function (line) {
            for (var i = this.slidesData.length - 1; i >= 0; i--) {
                if (line >= this.slidesData[i].line) {
                    var _a = this.slidesData[i], h = _a.h, v = _a.v, offset = _a.offset;
                    if (offset === this.currentSlideOffset) {
                        return;
                    }
                    this.currentSlideOffset = offset;
                    window["Reveal"].slide(h, v);
                    break;
                }
            }
        };
        /**
         * scroll preview to match `line`
         * @param line: the buffer row of editor
         */
        PreviewController.prototype.scrollSyncToLine = function (line, topRatio) {
            if (topRatio === void 0) { topRatio = 0.372; }
            if (!this.scrollMap) {
                this.scrollMap = this.buildScrollMap();
            }
            if (!this.scrollMap || line >= this.scrollMap.length) {
                return;
            }
            if (line + 1 === this.totalLineCount) {
                // last line
                this.scrollToPos(this.previewElement.scrollHeight);
            }
            else {
                /**
                 * Since I am not able to access the viewport of the editor
                 * I used `golden section` (0.372) here for scrollTop.
                 */
                this.scrollToPos(Math.max(this.scrollMap[line] - this.previewElement.offsetHeight * topRatio, 0));
            }
        };
        /**
         * Smoothly scroll the previewElement to `scrollTop` position.
         * @param scrollTop: the scrollTop position that the previewElement should be at
         */
        PreviewController.prototype.scrollToPos = function (scrollTop) {
            var _this = this;
            if (this.scrollTimeout) {
                clearTimeout(this.scrollTimeout);
                this.scrollTimeout = null;
            }
            if (scrollTop < 0) {
                return;
            }
            var delay = 10;
            var helper = function (duration) {
                if (duration === void 0) { duration = 0; }
                _this.scrollTimeout = setTimeout(function () {
                    if (duration <= 0) {
                        _this.previewScrollDelay = Date.now() + 500;
                        _this.previewElement.scrollTop = scrollTop;
                        return;
                    }
                    var difference = scrollTop - _this.previewElement.scrollTop;
                    var perTick = (difference / duration) * delay;
                    // disable preview onscroll
                    _this.previewScrollDelay = Date.now() + 500;
                    _this.previewElement.scrollTop += perTick;
                    if (_this.previewElement.scrollTop === scrollTop) {
                        return;
                    }
                    helper(duration - delay);
                }, delay);
            };
            var scrollDuration = 120;
            helper(scrollDuration);
        };
        /**
         * It's unfortunate that I am not able to access the viewport.
         * @param line
         */
        PreviewController.prototype.scrollToRevealSourceLine = function (line, topRatio) {
            if (topRatio === void 0) { topRatio = 0.372; }
            if (line === this.currentLine) {
                return;
            }
            else {
                this.currentLine = line;
            }
            // disable preview onscroll
            this.previewScrollDelay = Date.now() + 500;
            if (this.presentationMode) {
                this.scrollSyncToSlide(line);
            }
            else {
                this.scrollSyncToLine(line, topRatio);
            }
        };
        /**
         * [esc] is pressed.
         */
        PreviewController.prototype.escPressed = function (event) {
            if (event === void 0) { event = null; }
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            if (this.config.vscode) {
                if (!this.presentationMode) {
                    this.toolbar.sidebarTOCBtn.click();
                }
            }
            else {
                if (window["$"]("#image-helper-view").is(":visible")) {
                    // close image helper
                    $["modal"].close();
                }
                else {
                    this.toolbar.sidebarTOCBtn.click();
                }
            }
        };
        /**
         * Initialize several `window` events.
         */
        PreviewController.prototype.initWindowEvents = function () {
            var _this = this;
            /**
             * Several keyboard events.
             */
            window.addEventListener("keydown", function (event) {
                if (event.shiftKey && event.ctrlKey && event.which === 83) {
                    // ctrl+shift+s preview sync source
                    return _this.previewSyncSource();
                }
                else if (event.metaKey || event.ctrlKey) {
                    // ctrl+c copy
                    if (event.which === 67) {
                        // [c] copy
                        document.execCommand("copy");
                    }
                    else if (event.which === 187 && !_this.config.vscode) {
                        // [+] zoom in
                        _this.zoomIn();
                    }
                    else if (event.which === 189 && !_this.config.vscode) {
                        // [-] zoom out
                        _this.zoomOut();
                    }
                    else if (event.which === 48 && !_this.config.vscode) {
                        // [0] reset zoom
                        _this.resetZoom();
                    }
                    else if (event.which === 38) {
                        // [ArrowUp] scroll to the most top
                        if (_this.presentationMode) {
                            window["Reveal"].slide(0);
                        }
                        else {
                            _this.previewElement.scrollTop = 0;
                        }
                    }
                }
                else if (event.which === 27) {
                    // [esc] toggle sidebar toc
                    _this.escPressed(event);
                }
            });
            window.addEventListener("resize", function () {
                _this.scrollMap = null;
            });
            window.addEventListener("message", function (event) {
                var data = event.data;
                if (!data) {
                    return;
                }
                // console.log('receive message: ' + data.command)
                if (data.command === "updateHTML") {
                    _this.totalLineCount = data.totalLineCount;
                    _this.sidebarTOCHTML = data.tocHTML;
                    _this.sourceUri = data.sourceUri;
                    _this.renderSidebarTOC();
                    _this.updateHTML(data.html, data.id, data["class"]);
                }
                else if (data.command === "changeTextEditorSelection" &&
                    (_this.config.scrollSync || data.forced)) {
                    var line = parseInt(data.line, 10);
                    var topRatio = parseFloat(data.topRatio);
                    if (isNaN(topRatio)) {
                        topRatio = 0.372;
                    }
                    console.log('scrollToRevealSouceLine');
                    _this.scrollToRevealSourceLine(line, topRatio);
                }
                else if (data.command === "startParsingMarkdown") {
                    /**
                     * show refreshingIcon after 1 second
                     * if preview hasn't finished rendering.
                     */
                    if (_this.refreshingIconTimeout) {
                        clearTimeout(_this.refreshingIconTimeout);
                    }
                    _this.refreshingIconTimeout = setTimeout(function () {
                        if (!_this.presentationMode) {
                            _this.refreshingIcon.style.display = "block";
                        }
                    }, 1000);
                }
                else if (data.command === "openImageHelper") {
                    window["$"]("#image-helper-view").modal();
                }
                else if (data.command === "runAllCodeChunks") {
                    _this.runAllCodeChunks();
                }
                else if (data.command === "runCodeChunk") {
                    _this.runNearestCodeChunk();
                }
                else if (data.command === "escPressed") {
                    _this.escPressed();
                }
                else if (data.command === "previewSyncSource") {
                    _this.previewSyncSource();
                }
                else if (data.command === "copy") {
                    document.execCommand("copy");
                }
                else if (data.command === "zommIn") {
                    _this.zoomIn();
                }
                else if (data.command === "zoomOut") {
                    _this.zoomOut();
                }
                else if (data.command === "resetZoom") {
                    _this.resetZoom();
                }
                else if (data.command === "scrollPreviewToTop") {
                    if (_this.presentationMode) {
                        window["Reveal"].slide(0);
                    }
                    else {
                        _this.previewElement.scrollTop = 0;
                    }
                }
            }, false);
        };
        return PreviewController;
    }());
    function onLoad() {
        /* tslint:disable-next-line:no-unused-expression */
        new PreviewController();
    }
    if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", onLoad);
    }
    else {
        onLoad();
    }
})();
